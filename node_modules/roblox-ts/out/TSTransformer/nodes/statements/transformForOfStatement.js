"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForOfStatement = void 0;
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformArrayBindingLiteral_1 = require("../binding/transformArrayBindingLiteral");
const transformBindingName_1 = require("../binding/transformBindingName");
const transformObjectBindingLiteral_1 = require("../binding/transformObjectBindingLiteral");
const transformExpression_1 = require("../expressions/transformExpression");
const transformInitializer_1 = require("../transformInitializer");
const transformStatementList_1 = require("../transformStatementList");
const transformWritable_1 = require("../transformWritable");
const getSubType_1 = require("../../util/binding/getSubType");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const getStatements_1 = require("../../util/getStatements");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
const validateIdentifier_1 = require("../../util/validateIdentifier");
const typescript_1 = __importDefault(require("typescript"));
function makeForLoopBuilder(callback) {
    return (state, statements, name, exp) => {
        const ids = LuauAST_1.default.list.make();
        const initializers = LuauAST_1.default.list.make();
        const expression = callback(state, name, exp, ids, initializers);
        LuauAST_1.default.list.unshiftList(statements, initializers);
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, { ids, expression, statements }));
    };
}
function getForInitializerAccessType(state, initializer) {
    const forOfStatement = initializer.parent;
    (0, assert_1.assert)(typescript_1.default.isForOfStatement(forOfStatement));
    return (0, getSubType_1.getSubType)(state, state.getType(forOfStatement.expression), 0);
}
function transformForInitializerExpressionDirect(state, initializer, initializers, value) {
    if (typescript_1.default.isArrayLiteralExpression(initializer)) {
        const [parentId, prereqs] = state.capture(() => {
            const parentId = state.pushToVar(value, "binding");
            (0, transformArrayBindingLiteral_1.transformArrayBindingLiteral)(state, initializer, parentId, getForInitializerAccessType(state, initializer));
            return parentId;
        });
        LuauAST_1.default.list.pushList(initializers, prereqs);
        return parentId;
    }
    else if (typescript_1.default.isObjectLiteralExpression(initializer)) {
        const [parentId, prereqs] = state.capture(() => {
            const parentId = state.pushToVar(value, "binding");
            (0, transformObjectBindingLiteral_1.transformObjectBindingLiteral)(state, initializer, parentId, getForInitializerAccessType(state, initializer));
            return parentId;
        });
        LuauAST_1.default.list.pushList(initializers, prereqs);
        return parentId;
    }
    else {
        const expression = (0, transformWritable_1.transformWritableExpression)(state, initializer, false);
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: expression,
            operator: "=",
            right: value,
        }));
    }
}
function transformForInitializer(state, initializer, initializers) {
    if (typescript_1.default.isVariableDeclarationList(initializer)) {
        return (0, transformBindingName_1.transformBindingName)(state, initializer.declarations[0].name, initializers);
    }
    else if (typescript_1.default.isArrayLiteralExpression(initializer)) {
        const parentId = LuauAST_1.default.tempId("binding");
        LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => (0, transformArrayBindingLiteral_1.transformArrayBindingLiteral)(state, initializer, parentId, getForInitializerAccessType(state, initializer))));
        return parentId;
    }
    else if (typescript_1.default.isObjectLiteralExpression(initializer)) {
        const parentId = LuauAST_1.default.tempId("binding");
        LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => (0, transformObjectBindingLiteral_1.transformObjectBindingLiteral)(state, initializer, parentId, getForInitializerAccessType(state, initializer))));
        return parentId;
    }
    else {
        const valueId = LuauAST_1.default.tempId("v");
        const expression = (0, transformWritable_1.transformWritableExpression)(state, initializer, false);
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: expression,
            operator: "=",
            right: valueId,
        }));
        return valueId;
    }
}
const buildArrayLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, LuauAST_1.default.tempId());
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.ipairs, [exp]);
});
const buildSetLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
});
function transformInLineArrayBindingPattern(state, pattern, ids, initializers) {
    for (const element of pattern.elements) {
        if (typescript_1.default.isOmittedExpression(element)) {
            LuauAST_1.default.list.push(ids, LuauAST_1.default.tempId());
        }
        else if (typescript_1.default.isSpreadElement(element)) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
        }
        else {
            const id = (0, transformBindingName_1.transformBindingName)(state, element.name, initializers);
            if (element.initializer) {
                LuauAST_1.default.list.push(initializers, (0, transformInitializer_1.transformInitializer)(state, id, element.initializer));
            }
            LuauAST_1.default.list.push(ids, id);
        }
    }
}
function transformInLineArrayBindingLiteral(state, bindingLiteral, ids, initializers) {
    LuauAST_1.default.list.pushList(initializers, state.capturePrereqs(() => {
        for (let element of bindingLiteral.elements) {
            if (typescript_1.default.isOmittedExpression(element)) {
                LuauAST_1.default.list.push(ids, LuauAST_1.default.tempId());
            }
            else if (typescript_1.default.isSpreadElement(element)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
            }
            else {
                let initializer;
                if (typescript_1.default.isBinaryExpression(element)) {
                    initializer = (0, traversal_1.skipDownwards)(element.right);
                    element = (0, traversal_1.skipDownwards)(element.left);
                }
                const valueId = LuauAST_1.default.tempId("binding");
                if (typescript_1.default.isIdentifier(element) ||
                    typescript_1.default.isElementAccessExpression(element) ||
                    typescript_1.default.isPropertyAccessExpression(element)) {
                    const id = (0, transformWritable_1.transformWritableExpression)(state, element, initializer !== undefined);
                    state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
                        left: id,
                        operator: "=",
                        right: valueId,
                    }));
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, id, initializer));
                    }
                }
                else if (typescript_1.default.isArrayLiteralExpression(element)) {
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, valueId, initializer));
                    }
                    (0, transformArrayBindingLiteral_1.transformArrayBindingLiteral)(state, element, valueId, state.getType(element));
                }
                else if (typescript_1.default.isObjectLiteralExpression(element)) {
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, valueId, initializer));
                    }
                    (0, transformObjectBindingLiteral_1.transformObjectBindingLiteral)(state, element, valueId, state.getType(element));
                }
                else {
                    (0, assert_1.assert)(false);
                }
                LuauAST_1.default.list.push(ids, valueId);
            }
        }
    }));
}
const buildMapLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    if (typescript_1.default.isVariableDeclarationList(initializer)) {
        const name = initializer.declarations[0].name;
        if (typescript_1.default.isArrayBindingPattern(name)) {
            transformInLineArrayBindingPattern(state, name, ids, initializers);
            return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
        }
    }
    else if (typescript_1.default.isArrayLiteralExpression(initializer)) {
        transformInLineArrayBindingLiteral(state, initializer, ids, initializers);
        return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
    }
    const keyId = LuauAST_1.default.tempId("k");
    const valueId = LuauAST_1.default.tempId("v");
    LuauAST_1.default.list.push(ids, keyId);
    LuauAST_1.default.list.push(ids, valueId);
    if (typescript_1.default.isVariableDeclarationList(initializer)) {
        const bindingList = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: transformForInitializer(state, initializer, bindingList),
            right: LuauAST_1.default.array([keyId, valueId]),
        }));
        LuauAST_1.default.list.pushList(initializers, bindingList);
    }
    else {
        transformForInitializerExpressionDirect(state, initializer, initializers, LuauAST_1.default.array([keyId, valueId]));
    }
    return LuauAST_1.default.call(LuauAST_1.default.globals.pairs, [exp]);
});
const buildStringLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return LuauAST_1.default.call(LuauAST_1.default.globals.string.gmatch, [exp, LuauAST_1.default.globals.utf8.charpattern]);
});
const buildIterableFunctionLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    LuauAST_1.default.list.push(ids, transformForInitializer(state, initializer, initializers));
    return exp;
});
function makeIterableFunctionLuaTupleShorthand(state, array, statements, expression) {
    const ids = LuauAST_1.default.list.make();
    const initializers = LuauAST_1.default.list.make();
    if (typescript_1.default.isArrayBindingPattern(array)) {
        transformInLineArrayBindingPattern(state, array, ids, initializers);
    }
    else {
        transformInLineArrayBindingLiteral(state, array, ids, initializers);
    }
    LuauAST_1.default.list.unshiftList(statements, initializers);
    return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ForStatement, { ids, expression, statements }));
}
const buildIterableFunctionLuaTupleLoop = type => (state, statements, initializer, exp) => {
    if (typescript_1.default.isVariableDeclarationList(initializer)) {
        const name = initializer.declarations[0].name;
        if (typescript_1.default.isArrayBindingPattern(name)) {
            return makeIterableFunctionLuaTupleShorthand(state, name, statements, exp);
        }
    }
    else if (typescript_1.default.isArrayLiteralExpression(initializer)) {
        return makeIterableFunctionLuaTupleShorthand(state, initializer, statements, exp);
    }
    const iteratorReturnIds = new Array();
    const luaTupleType = type.getCallSignatures()[0].getReturnType();
    (0, assert_1.assert)(luaTupleType && luaTupleType.aliasTypeArguments && luaTupleType.aliasTypeArguments.length === 1, "Incorrect LuaTuple<T> type arguments");
    const tupleArgType = luaTupleType.aliasTypeArguments[0];
    if (state.typeChecker.isTupleType(tupleArgType) && typescript_1.default.isVariableDeclarationList(initializer)) {
        const typeArguments = (0, types_1.getTypeArguments)(state, tupleArgType);
        for (let i = 0; i < typeArguments.length; i++) {
            iteratorReturnIds.push(LuauAST_1.default.tempId("element"));
        }
    }
    else {
        const iterFuncId = state.pushToVar(exp, "iterFunc");
        const loopStatements = LuauAST_1.default.list.make();
        const initializerStatements = LuauAST_1.default.list.make();
        const valueId = transformForInitializer(state, initializer, initializerStatements);
        LuauAST_1.default.list.push(loopStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: valueId,
            right: LuauAST_1.default.array([LuauAST_1.default.call(iterFuncId)]),
        }));
        LuauAST_1.default.list.push(loopStatements, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
            condition: LuauAST_1.default.binary(LuauAST_1.default.unary("#", valueId), "==", LuauAST_1.default.number(0)),
            statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
            elseBody: LuauAST_1.default.list.make(),
        }));
        LuauAST_1.default.list.pushList(loopStatements, initializerStatements);
        LuauAST_1.default.list.pushList(loopStatements, statements);
        return LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.WhileStatement, {
            condition: LuauAST_1.default.bool(true),
            statements: loopStatements,
        }));
    }
    const tupleId = transformForInitializer(state, initializer, statements);
    const builder = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
        for (const id of iteratorReturnIds) {
            LuauAST_1.default.list.push(ids, id);
        }
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: tupleId,
            right: LuauAST_1.default.array(iteratorReturnIds),
        }));
        return exp;
    });
    return builder(state, statements, initializer, exp);
};
const buildGeneratorLoop = makeForLoopBuilder((state, initializer, exp, ids, initializers) => {
    const loopId = LuauAST_1.default.tempId("result");
    LuauAST_1.default.list.push(ids, loopId);
    LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.IfStatement, {
        condition: LuauAST_1.default.property(loopId, "done"),
        statements: LuauAST_1.default.list.make(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.BreakStatement, {})),
        elseBody: LuauAST_1.default.list.make(),
    }));
    if (typescript_1.default.isVariableDeclarationList(initializer)) {
        const bindingList = LuauAST_1.default.list.make();
        LuauAST_1.default.list.push(initializers, LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: transformForInitializer(state, initializer, bindingList),
            right: LuauAST_1.default.property(loopId, "value"),
        }));
        LuauAST_1.default.list.pushList(initializers, bindingList);
    }
    else {
        transformForInitializerExpressionDirect(state, initializer, initializers, LuauAST_1.default.property(loopId, "value"));
    }
    return LuauAST_1.default.property((0, convertToIndexableExpression_1.convertToIndexableExpression)(exp), "next");
});
function getLoopBuilder(state, node, type) {
    if ((0, types_1.isDefinitelyType)(type, (0, types_1.isArrayType)(state))) {
        return buildArrayLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isSetType)(state))) {
        return buildSetLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isMapType)(state))) {
        return buildMapLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, t => (0, types_1.isStringType)(t))) {
        return buildStringLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isIterableFunctionLuaTupleType)(state))) {
        return buildIterableFunctionLuaTupleLoop(type);
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isIterableFunctionType)(state))) {
        return buildIterableFunctionLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isGeneratorType)(state))) {
        return buildGeneratorLoop;
    }
    else if ((0, types_1.isDefinitelyType)(type, (0, types_1.isIterableType)(state))) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noIterableIteration(node));
        return () => LuauAST_1.default.list.make();
    }
    else if (type.isUnion()) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noMacroUnion(node));
        return () => LuauAST_1.default.list.make();
    }
    else {
        (0, assert_1.assert)(false, `ForOf iteration type not implemented: ${state.typeChecker.typeToString(type)}`);
    }
}
function transformForOfStatement(state, node) {
    if (node.awaitModifier) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noAwaitForOf(node));
    }
    if (typescript_1.default.isVariableDeclarationList(node.initializer)) {
        const name = node.initializer.declarations[0].name;
        if (typescript_1.default.isIdentifier(name)) {
            (0, validateIdentifier_1.validateIdentifier)(state, name);
        }
    }
    const result = LuauAST_1.default.list.make();
    const [exp, expPrereqs] = state.capture(() => (0, transformExpression_1.transformExpression)(state, node.expression));
    LuauAST_1.default.list.pushList(result, expPrereqs);
    const expType = state.getType(node.expression);
    const statements = (0, transformStatementList_1.transformStatementList)(state, (0, getStatements_1.getStatements)(node.statement));
    const loopBuilder = getLoopBuilder(state, node.expression, expType);
    LuauAST_1.default.list.pushList(result, loopBuilder(state, statements, node.initializer, exp));
    return result;
}
exports.transformForOfStatement = transformForOfStatement;
//# sourceMappingURL=transformForOfStatement.js.map