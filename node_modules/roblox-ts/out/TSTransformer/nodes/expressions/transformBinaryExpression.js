"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformBinaryExpression = void 0;
const LuauAST_1 = __importDefault(require("../../../LuauAST"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const transformArrayBindingLiteral_1 = require("../binding/transformArrayBindingLiteral");
const transformObjectBindingLiteral_1 = require("../binding/transformObjectBindingLiteral");
const transformExpression_1 = require("./transformExpression");
const transformInitializer_1 = require("../transformInitializer");
const transformLogical_1 = require("../transformLogical");
const transformLogicalOrCoalescingAssignmentExpression_1 = require("../transformLogicalOrCoalescingAssignmentExpression");
const transformWritable_1 = require("../transformWritable");
const assignment_1 = require("../../util/assignment");
const getSubType_1 = require("../../util/binding/getSubType");
const convertToIndexableExpression_1 = require("../../util/convertToIndexableExpression");
const createBinaryFromOperator_1 = require("../../util/createBinaryFromOperator");
const ensureTransformOrder_1 = require("../../util/ensureTransformOrder");
const isUsedAsStatement_1 = require("../../util/isUsedAsStatement");
const traversal_1 = require("../../util/traversal");
const types_1 = require("../../util/types");
const validateNotAny_1 = require("../../util/validateNotAny");
const typescript_1 = __importDefault(require("typescript"));
function transformLuaTupleDestructure(state, bindingLiteral, value, accessType) {
    let index = 0;
    const variables = LuauAST_1.default.list.make();
    const writes = LuauAST_1.default.list.make();
    const statements = state.capturePrereqs(() => {
        for (let element of bindingLiteral.elements) {
            if (typescript_1.default.isOmittedExpression(element)) {
                LuauAST_1.default.list.push(writes, LuauAST_1.default.tempId());
            }
            else if (typescript_1.default.isSpreadElement(element)) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noSpreadDestructuring(element));
            }
            else {
                let initializer;
                if (typescript_1.default.isBinaryExpression(element)) {
                    initializer = (0, traversal_1.skipDownwards)(element.right);
                    element = (0, traversal_1.skipDownwards)(element.left);
                }
                if (typescript_1.default.isIdentifier(element) ||
                    typescript_1.default.isElementAccessExpression(element) ||
                    typescript_1.default.isPropertyAccessExpression(element)) {
                    const id = (0, transformWritable_1.transformWritableExpression)(state, element, true);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, id, initializer));
                    }
                }
                else if (typescript_1.default.isArrayLiteralExpression(element)) {
                    const id = LuauAST_1.default.tempId("binding");
                    LuauAST_1.default.list.push(variables, id);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, id, initializer));
                    }
                    (0, transformArrayBindingLiteral_1.transformArrayBindingLiteral)(state, element, id, (0, getSubType_1.getSubType)(state, accessType, index));
                }
                else if (typescript_1.default.isObjectLiteralExpression(element)) {
                    const id = LuauAST_1.default.tempId("binding");
                    LuauAST_1.default.list.push(variables, id);
                    LuauAST_1.default.list.push(writes, id);
                    if (initializer) {
                        state.prereq((0, transformInitializer_1.transformInitializer)(state, id, initializer));
                    }
                    (0, transformObjectBindingLiteral_1.transformObjectBindingLiteral)(state, element, id, (0, getSubType_1.getSubType)(state, accessType, index));
                }
                else {
                    (0, assert_1.assert)(false);
                }
            }
            index++;
        }
    });
    if (!LuauAST_1.default.list.isEmpty(variables)) {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
            left: variables,
            right: undefined,
        }));
    }
    if (LuauAST_1.default.list.isEmpty(writes)) {
        if (LuauAST_1.default.isCall(value)) {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.CallStatement, {
                expression: value,
            }));
        }
        else {
            state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.VariableDeclaration, {
                left: LuauAST_1.default.list.make(LuauAST_1.default.tempId()),
                right: value,
            }));
        }
    }
    else {
        state.prereq(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.Assignment, {
            left: writes,
            operator: "=",
            right: value,
        }));
    }
    state.prereqList(statements);
}
function transformBinaryExpression(state, node) {
    const operatorKind = node.operatorToken.kind;
    (0, validateNotAny_1.validateNotAnyType)(state, node.left);
    (0, validateNotAny_1.validateNotAnyType)(state, node.right);
    if (operatorKind === typescript_1.default.SyntaxKind.EqualsEqualsToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noEqualsEquals(node));
        return LuauAST_1.default.nil();
    }
    else if (operatorKind === typescript_1.default.SyntaxKind.ExclamationEqualsToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noExclamationEquals(node));
        return LuauAST_1.default.nil();
    }
    else if (operatorKind === typescript_1.default.SyntaxKind.CommaToken) {
        DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noComma(node));
        return LuauAST_1.default.nil();
    }
    if (operatorKind === typescript_1.default.SyntaxKind.AmpersandAmpersandToken ||
        operatorKind === typescript_1.default.SyntaxKind.BarBarToken ||
        operatorKind === typescript_1.default.SyntaxKind.QuestionQuestionToken) {
        return (0, transformLogical_1.transformLogical)(state, node);
    }
    if (typescript_1.default.isLogicalOrCoalescingAssignmentExpression(node)) {
        return (0, transformLogicalOrCoalescingAssignmentExpression_1.transformLogicalOrCoalescingAssignmentExpression)(state, node);
    }
    if (typescript_1.default.isAssignmentOperator(operatorKind)) {
        if (typescript_1.default.isArrayLiteralExpression(node.left)) {
            const rightExp = (0, transformExpression_1.transformExpression)(state, node.right);
            const accessType = state.getType(node.right);
            if (LuauAST_1.default.isCall(rightExp) && (0, types_1.isLuaTupleType)(state)(accessType)) {
                transformLuaTupleDestructure(state, node.left, rightExp, accessType);
                if (!(0, isUsedAsStatement_1.isUsedAsStatement)(node)) {
                    DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noDestructureAssignmentExpression(node));
                }
                return LuauAST_1.default.nil();
            }
            const parentId = state.pushToVar(rightExp, "binding");
            (0, transformArrayBindingLiteral_1.transformArrayBindingLiteral)(state, node.left, parentId, accessType);
            return parentId;
        }
        else if (typescript_1.default.isObjectLiteralExpression(node.left)) {
            const parentId = state.pushToVar((0, transformExpression_1.transformExpression)(state, node.right), "binding");
            const accessType = state.getType(node.right);
            (0, transformObjectBindingLiteral_1.transformObjectBindingLiteral)(state, node.left, parentId, accessType);
            return parentId;
        }
        const writableType = state.getType(node.left);
        const valueType = state.getType(node.right);
        const operator = (0, assignment_1.getSimpleAssignmentOperator)(writableType, operatorKind, valueType);
        const { writable, readable, value } = (0, transformWritable_1.transformWritableAssignment)(state, node.left, node.right, true, operator === undefined);
        if (operator !== undefined) {
            return (0, assignment_1.createAssignmentExpression)(state, writable, operator, operator === "..=" && !(0, types_1.isDefinitelyType)(valueType, types_1.isStringType)
                ? LuauAST_1.default.call(LuauAST_1.default.globals.tostring, [value])
                : value);
        }
        else {
            return (0, assignment_1.createCompoundAssignmentExpression)(state, node, writable, writableType, readable, operatorKind, value, valueType);
        }
    }
    const [left, right] = (0, ensureTransformOrder_1.ensureTransformOrder)(state, [node.left, node.right]);
    if (operatorKind === typescript_1.default.SyntaxKind.InKeyword) {
        return LuauAST_1.default.binary(LuauAST_1.default.create(LuauAST_1.default.SyntaxKind.ComputedIndexExpression, {
            expression: (0, convertToIndexableExpression_1.convertToIndexableExpression)(right),
            index: left,
        }), "~=", LuauAST_1.default.nil());
    }
    else if (operatorKind === typescript_1.default.SyntaxKind.InstanceOfKeyword) {
        return LuauAST_1.default.call(state.TS(node, "instanceof"), [left, right]);
    }
    const leftType = state.getType(node.left);
    const rightType = state.getType(node.right);
    if (operatorKind === typescript_1.default.SyntaxKind.LessThanToken ||
        operatorKind === typescript_1.default.SyntaxKind.LessThanEqualsToken ||
        operatorKind === typescript_1.default.SyntaxKind.GreaterThanToken ||
        operatorKind === typescript_1.default.SyntaxKind.GreaterThanEqualsToken) {
        if ((!(0, types_1.isDefinitelyType)(leftType, types_1.isStringType) && !(0, types_1.isDefinitelyType)(leftType, types_1.isNumberType)) ||
            (!(0, types_1.isDefinitelyType)(rightType, types_1.isStringType) && !(0, types_1.isDefinitelyType)(leftType, types_1.isNumberType))) {
            DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noNonNumberStringRelationOperator(node));
        }
    }
    return (0, createBinaryFromOperator_1.createBinaryFromOperator)(state, node, left, leftType, operatorKind, right, rightType);
}
exports.transformBinaryExpression = transformBinaryExpression;
//# sourceMappingURL=transformBinaryExpression.js.map